
#define RETURNS_VOID_0
#define RETURNS_VOID_1
#define RETURNS_VOID_2
#define RETURNS_VOID_3
#define RETURNS_VOID_4
#define RETURNS_VOID_5
#define RETURNS_VOID_6
#define RETURNS_VOID_7
#define RETURNS_VOID_8
#define RETURNS_VOID_9
#define RETURNS_VOID_10
#define RETURNS_VOID_11
#define RETURNS_VOID_12
#define RETURNS_VOID_13
#define RETURNS_VOID_14
#define RETURNS_VOID_15
#define RETURNS_VOID_16
#define RETURNS_VOID_17
#define RETURNS_VOID_18
#define RETURNS_VOID_19
#define RETURNS_VOID_20
#define RETURNS_VOID_21
#define RETURNS_VOID_22
#define RETURNS_VOID_23
#define RETURNS_VOID_24
#define RETURNS_VOID_25
#define RETURNS_VOID_26
#define RETURNS_VOID_27
#define RETURNS_VOID_28
#define RETURNS_VOID_29
#define RETURNS_VOID_30
#define RETURNS_VOID_31
#define RETURNS_VOID_32
#define RETURNS_VOID_33
#define RETURNS_VOID_34
#define RETURNS_VOID_35
#define RETURNS_VOID_36
#define RETURNS_VOID_37
#define RETURNS_VOID_38
#define RETURNS_VOID_39
#define RETURNS_VOID_40
#define RETURNS_VOID_41
#define RETURNS_VOID_42
#define RETURNS_VOID_43
#define RETURNS_VOID_44
#define RETURNS_VOID_45
#define RETURNS_VOID_46
#define RETURNS_VOID_47
#define RETURNS_VOID_48
#define RETURNS_VOID_49
#define RETURNS_VOID_50
#define RETURNS_VOID_51
#define RETURNS_VOID_52
#define RETURNS_VOID_53
#define RETURNS_VOID_54
#define RETURNS_VOID_55
#define RETURNS_VOID_56
#define RETURNS_VOID_57
#define RETURNS_VOID_58
#define RETURNS_VOID_59
#define RETURNS_VOID_60
#define RETURNS_VOID_61
#define RETURNS_VOID_62
#define RETURNS_VOID_63
#define RETURNS_VOID_64
#define RETURNS_VOID_65
#define RETURNS_VOID_66
#define RETURNS_VOID_67
#define RETURNS_VOID_68
#define RETURNS_VOID_69
#define RETURNS_VOID_70
#define RETURNS_VOID_71
#define RETURNS_VOID_72
#define RETURNS_VOID_73
#define RETURNS_VOID_74
#define RETURNS_VOID_75
#define RETURNS_VOID_76
#define RETURNS_VOID_77
#define RETURNS_VOID_78
#define RETURNS_VOID_79
#define RETURNS_VOID_80
#define RETURNS_VOID_81
#define RETURNS_VOID_82
#define RETURNS_VOID_83
#define RETURNS_VOID_84
#define RETURNS_VOID_85
#define RETURNS_VOID_86
#define RETURNS_VOID_87
#define RETURNS_VOID_88
#define RETURNS_VOID_89
#define RETURNS_VOID_90
#define RETURNS_VOID_91
#define RETURNS_VOID_92
#define RETURNS_VOID_93
#define RETURNS_VOID_94
#define RETURNS_VOID_95
#define RETURNS_VOID_96
#define RETURNS_VOID_97
#define RETURNS_VOID_98
#define RETURNS_VOID_99
#define RETURNS_VOID_100
#define RETURNS_VOID_101
#define RETURNS_VOID_102
#define RETURNS_VOID_103
#define RETURNS_VOID_104
#define RETURNS_VOID_105
#define RETURNS_VOID_106
#define RETURNS_VOID_107
#define RETURNS_VOID_108
#define RETURNS_VOID_109
#define RETURNS_VOID_110
#define RETURNS_VOID_111
#define RETURNS_VOID_112
#define RETURNS_VOID_113
#define RETURNS_VOID_114
#define RETURNS_VOID_115
#define RETURNS_VOID_116
#define RETURNS_VOID_117
#define RETURNS_VOID_118
#define RETURNS_VOID_119
#define NETFRAMEWORK
// <auto-generated />

// this file must not be importing any namespaces
// we should use full names everywhere to avoid any potential naming conflicts, example: #1007, #778

// the namespace name must be in sync with WindowsDisassembler.BuildArguments
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        
        public static System.Int32 Main(System.String[] args)
        {
            // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls! (CoreRT is exception from this rule)
            // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event
            // before .NET Framework tries to load it for this method
#if NETFRAMEWORK
            using(new DirtyAssemblyResolveHelper())
#endif
                return AfterAssemblyLoadingAttached(args);
        }

        private static System.Int32 AfterAssemblyLoadingAttached(System.String[] args)
        {
#if WASM
            BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost host = new BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost(System.Console.Out); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
#else
            BenchmarkDotNet.Engines.ConsoleHost host = new BenchmarkDotNet.Engines.ConsoleHost(System.Console.Out, new System.IO.StreamReader(System.Console.OpenStandardInput(), System.Text.Encoding.UTF8)); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
#endif

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            BenchmarkDotNet.Engines.HostExtensions.BeforeAnythingElse(host);

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it
                System.String benchmarkName = System.Linq.Enumerable.FirstOrDefault(System.Linq.Enumerable.Skip(System.Linq.Enumerable.SkipWhile(args, arg => arg != "--benchmarkName"), 1)) ?? "not provided";
                System.Int32 id = System.Int32.Parse(args[args.Length - 1]); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it

#if CORERT
                
#else
                System.Type type = typeof(BenchmarkDotNet.Autogenerated.UniqueProgramName).Assembly.GetType($"BenchmarkDotNet.Autogenerated.Runnable_{id}");
                type.GetMethod("Run", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static).Invoke(null, new System.Object[] { host, benchmarkName });
#endif
                return 0;
            }
            catch (System.Exception oom) when (oom is System.OutOfMemoryException || oom is System.Reflection.TargetInvocationException reflection && reflection.InnerException is System.OutOfMemoryException)
            {
                host.WriteLine();
                host.WriteLine("OutOfMemoryException!");
                host.WriteLine("BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.");
                host.WriteLine("If your benchmark allocates memory and keeps it alive, you are creating a memory leak.");
                host.WriteLine("You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.");
                host.WriteLine();
                host.WriteLine(oom.ToString());

                return -1;
            }
            catch(System.Exception ex)
            {
                host.WriteLine();
                host.WriteLine(ex.ToString());
                return -1;
            }
            finally
            {
                BenchmarkDotNet.Engines.HostExtensions.AfterAll(host);
            }
        }
    }

#if NETFRAMEWORK
    internal class DirtyAssemblyResolveHelper : System.IDisposable
    {
        internal DirtyAssemblyResolveHelper() => System.AppDomain.CurrentDomain.AssemblyResolve += HelpTheFrameworkToResolveTheAssembly;

        public void Dispose() => System.AppDomain.CurrentDomain.AssemblyResolve -= HelpTheFrameworkToResolveTheAssembly;

        /// <summary>
        /// according to https://msdn.microsoft.com/en-us/library/ff527268(v=vs.110).aspx
        /// "the handler is invoked whenever the runtime fails to bind to an assembly by name."
        /// </summary>
        /// <returns>not null when we find it manually, null when can't help</returns>
        private System.Reflection.Assembly HelpTheFrameworkToResolveTheAssembly(System.Object sender, System.ResolveEventArgs args)
        {
#if SHADOWCOPY // used for LINQPad
            const System.String shadowCopyFolderPath = @"";

            System.String guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $"{new System.Reflection.AssemblyName(args.Name).Name}.dll");

            return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;
#else
            System.Reflection.AssemblyName fullName = new System.Reflection.AssemblyName(args.Name);
            System.String simpleName = fullName.Name;

            System.String guessedPath = System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, $"{simpleName}.dll");

            if (!System.IO.File.Exists(guessedPath))
            {
                System.Console.WriteLine($"// Wrong assembly binding redirects for {args.Name}.");
                return null; // we can't help, and we also don't call Assembly.Load which if fails comes back here, creates endless loop and causes StackOverflow
            }

            // the file is right there, but has most probably different version and there is no assembly binding redirect or there is a wrong one...
            // so we just load it and ignore the version mismatch

            // we warn the user about that, in case some Super User want to be aware of that
            System.Console.WriteLine($"// Wrong assembly binding redirects for {simpleName}, loading it from disk anyway.");

            return System.Reflection.Assembly.LoadFrom(guessedPath);
#endif // SHADOWCOPY
        }
    }
#endif // NETFRAMEWORK

        // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_0 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_0 instance = new BenchmarkDotNet.Autogenerated.Runnable_0(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_0()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_0.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_0.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_0

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_0

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_0

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_0

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_0

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_1 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_1 instance = new BenchmarkDotNet.Autogenerated.Runnable_1(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_1()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_1.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_1.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_1

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_1

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_1

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_1

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_1

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_2 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_2 instance = new BenchmarkDotNet.Autogenerated.Runnable_2(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_2()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_2.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_2.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_2

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_2

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_2

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_2

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_2

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_3 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_3 instance = new BenchmarkDotNet.Autogenerated.Runnable_3(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_3()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_3.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_3.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_3

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_3

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_3

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_3

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_3

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_4 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_4 instance = new BenchmarkDotNet.Autogenerated.Runnable_4(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_4()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_4.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_4.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_4

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_4

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_4

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_4

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_4

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_5 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_5 instance = new BenchmarkDotNet.Autogenerated.Runnable_5(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_5()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_5.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_5.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_5

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_5

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_5

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_5

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_5

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_6 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_6 instance = new BenchmarkDotNet.Autogenerated.Runnable_6(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_6()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_6.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_6.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_6

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_6

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_6

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_6

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_6

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_7 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_7 instance = new BenchmarkDotNet.Autogenerated.Runnable_7(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_7()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_7.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_7.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_7

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_7

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_7

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_7

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_7

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_8 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_8 instance = new BenchmarkDotNet.Autogenerated.Runnable_8(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_8()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_8.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_8.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_8

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_8

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_8

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_8

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_8

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_9 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_9 instance = new BenchmarkDotNet.Autogenerated.Runnable_9(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_9()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_9.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_9.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_9

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_9

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_9

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_9

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_9

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_10 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_10 instance = new BenchmarkDotNet.Autogenerated.Runnable_10(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_10()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_10.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_10.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_10

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_10

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_10

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_10

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_10

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_11 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_11 instance = new BenchmarkDotNet.Autogenerated.Runnable_11(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_11()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_11.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_11.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_11

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_11

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_11

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_11

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_11

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_12 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_12 instance = new BenchmarkDotNet.Autogenerated.Runnable_12(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_12()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_12.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_12.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_12

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_12

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_12

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_12

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_12

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_13 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_13 instance = new BenchmarkDotNet.Autogenerated.Runnable_13(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_13()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_13.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_13.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_13

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_13

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_13

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_13

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_13

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_14 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_14 instance = new BenchmarkDotNet.Autogenerated.Runnable_14(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(0);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_14()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_14.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_14.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_14

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_14

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_14

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_14

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_14

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_15 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_15 instance = new BenchmarkDotNet.Autogenerated.Runnable_15(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_15()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_15.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_15.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_15

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_15

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_15

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_15

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_15

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_16 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_16 instance = new BenchmarkDotNet.Autogenerated.Runnable_16(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_16()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_16.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_16.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_16

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_16

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_16

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_16

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_16

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_17 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_17 instance = new BenchmarkDotNet.Autogenerated.Runnable_17(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_17()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_17.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_17.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_17

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_17

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_17

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_17

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_17

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_18 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_18 instance = new BenchmarkDotNet.Autogenerated.Runnable_18(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_18()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_18.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_18.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_18

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_18

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_18

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_18

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_18

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_19 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_19 instance = new BenchmarkDotNet.Autogenerated.Runnable_19(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_19()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_19.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_19.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_19

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_19

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_19

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_19

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_19

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_20 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_20 instance = new BenchmarkDotNet.Autogenerated.Runnable_20(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_20()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_20.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_20.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_20

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_20

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_20

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_20

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_20

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_21 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_21 instance = new BenchmarkDotNet.Autogenerated.Runnable_21(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_21()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_21.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_21.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_21

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_21

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_21

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_21

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_21

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_22 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_22 instance = new BenchmarkDotNet.Autogenerated.Runnable_22(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_22()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_22.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_22.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_22

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_22

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_22

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_22

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_22

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_23 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_23 instance = new BenchmarkDotNet.Autogenerated.Runnable_23(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_23()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_23.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_23.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_23

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_23

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_23

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_23

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_23

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_24 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_24 instance = new BenchmarkDotNet.Autogenerated.Runnable_24(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_24()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_24.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_24.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_24

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_24

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_24

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_24

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_24

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_25 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_25 instance = new BenchmarkDotNet.Autogenerated.Runnable_25(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_25()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_25.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_25.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_25

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_25

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_25

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_25

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_25

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_26 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_26 instance = new BenchmarkDotNet.Autogenerated.Runnable_26(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_26()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_26.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_26.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_26

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_26

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_26

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_26

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_26

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_27 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_27 instance = new BenchmarkDotNet.Autogenerated.Runnable_27(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_27()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_27.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_27.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_27

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_27

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_27

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_27

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_27

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_28 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_28 instance = new BenchmarkDotNet.Autogenerated.Runnable_28(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_28()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_28.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_28.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_28

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_28

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_28

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_28

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_28

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_29 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_29 instance = new BenchmarkDotNet.Autogenerated.Runnable_29(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(1);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_29()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_29.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_29.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_29

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_29

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_29

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_29

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_29

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_30 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_30 instance = new BenchmarkDotNet.Autogenerated.Runnable_30(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_30()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_30.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_30.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_30

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_30

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_30

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_30

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_30

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_31 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_31 instance = new BenchmarkDotNet.Autogenerated.Runnable_31(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_31()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_31.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_31.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_31

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_31

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_31

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_31

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_31

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_32 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_32 instance = new BenchmarkDotNet.Autogenerated.Runnable_32(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_32()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_32.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_32.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_32

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_32

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_32

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_32

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_32

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_33 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_33 instance = new BenchmarkDotNet.Autogenerated.Runnable_33(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_33()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_33.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_33.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_33

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_33

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_33

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_33

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_33

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_34 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_34 instance = new BenchmarkDotNet.Autogenerated.Runnable_34(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_34()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_34.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_34.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_34

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_34

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_34

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_34

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_34

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_35 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_35 instance = new BenchmarkDotNet.Autogenerated.Runnable_35(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_35()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_35.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_35.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_35

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_35

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_35

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_35

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_35

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_36 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_36 instance = new BenchmarkDotNet.Autogenerated.Runnable_36(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_36()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_36.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_36.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_36

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_36

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_36

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_36

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_36

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_37 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_37 instance = new BenchmarkDotNet.Autogenerated.Runnable_37(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_37()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_37.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_37.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_37

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_37

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_37

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_37

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_37

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_38 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_38 instance = new BenchmarkDotNet.Autogenerated.Runnable_38(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_38()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_38.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_38.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_38

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_38

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_38

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_38

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_38

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_39 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_39 instance = new BenchmarkDotNet.Autogenerated.Runnable_39(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_39()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_39.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_39.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_39

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_39

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_39

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_39

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_39

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_40 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_40 instance = new BenchmarkDotNet.Autogenerated.Runnable_40(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_40()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_40.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_40.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_40

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_40

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_40

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_40

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_40

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_41 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_41 instance = new BenchmarkDotNet.Autogenerated.Runnable_41(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_41()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_41.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_41.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_41

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_41

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_41

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_41

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_41

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_42 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_42 instance = new BenchmarkDotNet.Autogenerated.Runnable_42(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_42()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_42.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_42.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_42

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_42

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_42

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_42

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_42

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_43 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_43 instance = new BenchmarkDotNet.Autogenerated.Runnable_43(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_43()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_43.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_43.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_43

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_43

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_43

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_43

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_43

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_44 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_44 instance = new BenchmarkDotNet.Autogenerated.Runnable_44(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(2);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_44()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_44.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_44.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_44

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_44

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_44

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_44

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_44

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_45 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_45 instance = new BenchmarkDotNet.Autogenerated.Runnable_45(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_45()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_45.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_45.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_45

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_45

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_45

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_45

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_45

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_46 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_46 instance = new BenchmarkDotNet.Autogenerated.Runnable_46(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_46()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_46.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_46.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_46

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_46

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_46

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_46

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_46

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_47 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_47 instance = new BenchmarkDotNet.Autogenerated.Runnable_47(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_47()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_47.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_47.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_47

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_47

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_47

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_47

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_47

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_48 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_48 instance = new BenchmarkDotNet.Autogenerated.Runnable_48(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_48()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_48.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_48.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_48

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_48

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_48

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_48

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_48

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_49 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_49 instance = new BenchmarkDotNet.Autogenerated.Runnable_49(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_49()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_49.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_49.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_49

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_49

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_49

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_49

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_49

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_50 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_50 instance = new BenchmarkDotNet.Autogenerated.Runnable_50(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_50()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_50.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_50.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_50

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_50

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_50

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_50

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_50

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_51 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_51 instance = new BenchmarkDotNet.Autogenerated.Runnable_51(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_51()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_51.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_51.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_51

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_51

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_51

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_51

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_51

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_52 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_52 instance = new BenchmarkDotNet.Autogenerated.Runnable_52(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_52()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_52.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_52.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_52

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_52

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_52

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_52

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_52

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_53 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_53 instance = new BenchmarkDotNet.Autogenerated.Runnable_53(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_53()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_53.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_53.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_53

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_53

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_53

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_53

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_53

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_54 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_54 instance = new BenchmarkDotNet.Autogenerated.Runnable_54(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_54()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_54.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_54.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_54

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_54

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_54

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_54

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_54

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_55 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_55 instance = new BenchmarkDotNet.Autogenerated.Runnable_55(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_55()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_55.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_55.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_55

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_55

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_55

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_55

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_55

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_56 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_56 instance = new BenchmarkDotNet.Autogenerated.Runnable_56(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_56()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_56.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_56.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_56

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_56

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_56

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_56

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_56

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_57 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_57 instance = new BenchmarkDotNet.Autogenerated.Runnable_57(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_57()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_57.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_57.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_57

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_57

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_57

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_57

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_57

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_58 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_58 instance = new BenchmarkDotNet.Autogenerated.Runnable_58(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_58()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_58.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_58.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_58

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_58

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_58

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_58

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_58

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_59 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_59 instance = new BenchmarkDotNet.Autogenerated.Runnable_59(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(3);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_59()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_59.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_59.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_59

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_59

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_59

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_59

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_59

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_60 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_60 instance = new BenchmarkDotNet.Autogenerated.Runnable_60(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_60()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_60.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_60.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_60

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_60

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_60

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_60

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_60

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_61 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_61 instance = new BenchmarkDotNet.Autogenerated.Runnable_61(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_61()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_61.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_61.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_61

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_61

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_61

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_61

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_61

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_62 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_62 instance = new BenchmarkDotNet.Autogenerated.Runnable_62(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_62()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_62.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_62.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_62

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_62

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_62

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_62

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_62

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_63 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_63 instance = new BenchmarkDotNet.Autogenerated.Runnable_63(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_63()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_63.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_63.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_63

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_63

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_63

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_63

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_63

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_64 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_64 instance = new BenchmarkDotNet.Autogenerated.Runnable_64(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_64()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_64.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_64.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_64

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_64

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_64

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_64

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_64

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_65 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_65 instance = new BenchmarkDotNet.Autogenerated.Runnable_65(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_65()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_65.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_65.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_65

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_65

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_65

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_65

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_65

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_66 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_66 instance = new BenchmarkDotNet.Autogenerated.Runnable_66(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_66()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_66.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_66.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_66

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_66

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_66

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_66

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_66

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_67 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_67 instance = new BenchmarkDotNet.Autogenerated.Runnable_67(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_67()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_67.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_67.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_67

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_67

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_67

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_67

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_67

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_68 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_68 instance = new BenchmarkDotNet.Autogenerated.Runnable_68(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_68()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_68.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_68.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_68

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_68

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_68

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_68

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_68

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_69 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_69 instance = new BenchmarkDotNet.Autogenerated.Runnable_69(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_69()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_69.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_69.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_69

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_69

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_69

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_69

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_69

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_70 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_70 instance = new BenchmarkDotNet.Autogenerated.Runnable_70(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_70()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_70.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_70.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_70

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_70

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_70

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_70

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_70

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_71 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_71 instance = new BenchmarkDotNet.Autogenerated.Runnable_71(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_71()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_71.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_71.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_71

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_71

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_71

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_71

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_71

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_72 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_72 instance = new BenchmarkDotNet.Autogenerated.Runnable_72(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_72()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_72.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_72.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_72

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_72

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_72

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_72

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_72

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_73 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_73 instance = new BenchmarkDotNet.Autogenerated.Runnable_73(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_73()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_73.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_73.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_73

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_73

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_73

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_73

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_73

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_74 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_74 instance = new BenchmarkDotNet.Autogenerated.Runnable_74(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(4);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_74()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_74.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_74.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_74

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_74

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_74

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_74

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_74

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_75 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_75 instance = new BenchmarkDotNet.Autogenerated.Runnable_75(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_75()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_75.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_75.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_75

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_75

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_75

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_75

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_75

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_76 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_76 instance = new BenchmarkDotNet.Autogenerated.Runnable_76(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_76()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_76.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_76.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_76

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_76

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_76

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_76

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_76

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_77 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_77 instance = new BenchmarkDotNet.Autogenerated.Runnable_77(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_77()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_77.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_77.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_77

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_77

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_77

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_77

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_77

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_78 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_78 instance = new BenchmarkDotNet.Autogenerated.Runnable_78(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_78()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_78.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_78.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_78

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_78

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_78

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_78

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_78

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_79 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_79 instance = new BenchmarkDotNet.Autogenerated.Runnable_79(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_79()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_79.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_79.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_79

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_79

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_79

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_79

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_79

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_80 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_80 instance = new BenchmarkDotNet.Autogenerated.Runnable_80(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_80()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_80.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_80.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_80

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_80

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_80

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_80

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_80

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_81 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_81 instance = new BenchmarkDotNet.Autogenerated.Runnable_81(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_81()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_81.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_81.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_81

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_81

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_81

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_81

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_81

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_82 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_82 instance = new BenchmarkDotNet.Autogenerated.Runnable_82(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_82()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_82.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_82.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_82

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_82

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_82

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_82

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_82

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_83 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_83 instance = new BenchmarkDotNet.Autogenerated.Runnable_83(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_83()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_83.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_83.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_83

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_83

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_83

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_83

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_83

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_84 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_84 instance = new BenchmarkDotNet.Autogenerated.Runnable_84(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_84()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_84.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_84.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_84

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_84

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_84

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_84

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_84

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_85 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_85 instance = new BenchmarkDotNet.Autogenerated.Runnable_85(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_85()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_85.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_85.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_85

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_85

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_85

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_85

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_85

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_86 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_86 instance = new BenchmarkDotNet.Autogenerated.Runnable_86(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_86()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_86.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_86.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_86

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_86

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_86

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_86

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_86

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_87 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_87 instance = new BenchmarkDotNet.Autogenerated.Runnable_87(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_87()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_87.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_87.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_87

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_87

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_87

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_87

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_87

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_88 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_88 instance = new BenchmarkDotNet.Autogenerated.Runnable_88(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_88()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_88.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_88.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_88

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_88

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_88

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_88

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_88

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_89 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_89 instance = new BenchmarkDotNet.Autogenerated.Runnable_89(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(5);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_89()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_89.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_89.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_89

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_89

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_89

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_89

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_89

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_90 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_90 instance = new BenchmarkDotNet.Autogenerated.Runnable_90(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_90()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_90.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_90.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_90

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_90

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_90

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_90

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_90

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_91 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_91 instance = new BenchmarkDotNet.Autogenerated.Runnable_91(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_91()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_91.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_91.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_91

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_91

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_91

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_91

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_91

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_92 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_92 instance = new BenchmarkDotNet.Autogenerated.Runnable_92(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_92()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_92.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_92.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_92

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_92

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_92

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_92

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_92

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_93 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_93 instance = new BenchmarkDotNet.Autogenerated.Runnable_93(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_93()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_93.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_93.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_93

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_93

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_93

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_93

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_93

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_94 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_94 instance = new BenchmarkDotNet.Autogenerated.Runnable_94(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_94()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_94.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_94.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_94

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_94

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_94

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_94

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_94

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_95 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_95 instance = new BenchmarkDotNet.Autogenerated.Runnable_95(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_95()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_95.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_95.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_95

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_95

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_95

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_95

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_95

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_96 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_96 instance = new BenchmarkDotNet.Autogenerated.Runnable_96(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_96()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_96.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_96.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_96

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_96

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_96

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_96

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_96

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_97 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_97 instance = new BenchmarkDotNet.Autogenerated.Runnable_97(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_97()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_97.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_97.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_97

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_97

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_97

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_97

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_97

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_98 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_98 instance = new BenchmarkDotNet.Autogenerated.Runnable_98(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_98()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_98.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_98.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_98

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_98

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_98

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_98

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_98

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_99 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_99 instance = new BenchmarkDotNet.Autogenerated.Runnable_99(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_99()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_99.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_99.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_99

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_99

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_99

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_99

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_99

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_100 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_100 instance = new BenchmarkDotNet.Autogenerated.Runnable_100(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_100()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_100.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_100.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_100

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_100

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_100

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_100

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_100

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_101 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_101 instance = new BenchmarkDotNet.Autogenerated.Runnable_101(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_101()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_101.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_101.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_101

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_101

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_101

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_101

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_101

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_102 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_102 instance = new BenchmarkDotNet.Autogenerated.Runnable_102(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_102()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_102.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_102.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_102

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_102

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_102

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_102

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_102

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_103 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_103 instance = new BenchmarkDotNet.Autogenerated.Runnable_103(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_103()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_103.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_103.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_103

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_103

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_103

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_103

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_103

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_104 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_104 instance = new BenchmarkDotNet.Autogenerated.Runnable_104(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(6);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_104()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_104.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_104.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_104

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_104

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_104

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_104

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_104

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_105 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_105 instance = new BenchmarkDotNet.Autogenerated.Runnable_105(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_105()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_105.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_105.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_105

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_105

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_105

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_105

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_105

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_106 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_106 instance = new BenchmarkDotNet.Autogenerated.Runnable_106(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_106()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_106.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_106.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_106

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_106

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_106

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_106

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_106

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_107 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_107 instance = new BenchmarkDotNet.Autogenerated.Runnable_107(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(0);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_107()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_107.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_107.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_107

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_107

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_107

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_107

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_107

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_108 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_108 instance = new BenchmarkDotNet.Autogenerated.Runnable_108(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_108()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_108.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_108.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_108

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_108

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_108

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_108

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_108

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_109 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_109 instance = new BenchmarkDotNet.Autogenerated.Runnable_109(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_109()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_109.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_109.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_109

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_109

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_109

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_109

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_109

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_110 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_110 instance = new BenchmarkDotNet.Autogenerated.Runnable_110(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(1);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_110()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_110.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_110.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_110

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_110

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_110

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_110

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_110

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_111 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_111 instance = new BenchmarkDotNet.Autogenerated.Runnable_111(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_111()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_111.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_111.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_111

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_111

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_111

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_111

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_111

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_112 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_112 instance = new BenchmarkDotNet.Autogenerated.Runnable_112(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_112()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_112.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_112.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_112

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_112

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_112

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_112

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_112

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_113 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_113 instance = new BenchmarkDotNet.Autogenerated.Runnable_113(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(2);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_113()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_113.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_113.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_113

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_113

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_113

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_113

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_113

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_114 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_114 instance = new BenchmarkDotNet.Autogenerated.Runnable_114(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_114()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_114.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_114.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_114

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_114

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_114

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_114

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_114

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_115 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_115 instance = new BenchmarkDotNet.Autogenerated.Runnable_115(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_115()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_115.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_115.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_115

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_115

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_115

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_115

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_115

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_116 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_116 instance = new BenchmarkDotNet.Autogenerated.Runnable_116(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(3);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_116()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_116.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_116.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_116

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_116

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_116

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_116

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_116

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_117 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_117 instance = new BenchmarkDotNet.Autogenerated.Runnable_117(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_117()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetAllComponents;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_117.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_117.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_117

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_117

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetAllComponents();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_117

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_117

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetAllComponents();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_117

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetAllComponents();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_118 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_118 instance = new BenchmarkDotNet.Autogenerated.Runnable_118(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_118()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = GetComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_118.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_118.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_118

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_118

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return GetComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_118

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_118

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref GetComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_118

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                GetComponent();
            }
        }
#endif
    }
    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe class Runnable_119 : global::EcsLte.BencharkTest.EcsContextTests.EcsContext_EntityComponentGetTest
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_119 instance = new BenchmarkDotNet.Autogenerated.Runnable_119(); // do NOT change name "instance" (used in SmartParamameter)
            instance.ComponentArrangement = (EcsLte.BencharkTest.EntityComponentArrangement)(7);instance.ContextType = (EcsLte.BencharkTest.EcsContextType)(4);

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            ;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1,
                MeasureExtraStats = true,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new BenchmarkDotNet.Engines.EngineFactory().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate void OverheadDelegate();

        public delegate  void WorkloadDelegate();

        public Runnable_119()
        {
            globalSetupAction = GlobalSetup;
            globalCleanupAction = GlobalCleanup;
            iterationSetupAction = () => { };
            iterationCleanupAction = () => { };
            overheadDelegate = __Overhead;
            workloadDelegate = HasComponent;
            
        }

        private System.Action globalSetupAction;
        private System.Action globalCleanupAction;
        private System.Action iterationSetupAction;
        private System.Action iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_119.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_119.WorkloadDelegate workloadDelegate;
        

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            __ForDisassemblyDiagnoser__();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private void __Overhead() // __ is to avoid possible name conflict
        {
            
        }

#if RETURNS_CONSUMABLE_119

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
                consumer.Consume(overheadDelegate());
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate());
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
                consumer.Consume(workloadDelegate());
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate());
            }
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_119

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void result = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate();
            }
            NonGenericKeepAliveWithoutBoxing(result);
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing(void _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return HasComponent();
            }
            
            return default(void);
        }

#elif RETURNS_BYREF_119

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_119

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            void value = default(void);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
        }

        private void workloadDefaultValueHolder = default(void);

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }
        
        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            ref void alias = ref workloadDefaultValueHolder;
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate();
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                return ref HasComponent();
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_119

        private void OverheadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
                overheadDelegate();
            }
        }

        private void OverheadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate();
            }
        }

        private void WorkloadActionUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
                workloadDelegate();
            }
        }

        private void WorkloadActionNoUnroll(System.Int64 invokeCount)
        {
            
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate();
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __ForDisassemblyDiagnoser__()
        {
            if (NotEleven == 11)
            {
                
                HasComponent();
            }
        }
#endif
    }
}
